# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": ["NoOp"]}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "create_game", "returns": {"type": "uint64"}, "desc": "Create a new game and return the game ID", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "game_id"}], "name": "join_game", "returns": {"type": "string"}, "desc": "Join an existing game as player 2", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "game_id"}, {"type": "uint64", "name": "move"}], "name": "submit_move", "returns": {"type": "string"}, "desc": "Submit your move (1=Rock, 2=Paper, 3=Scissors)", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "game_id"}], "name": "get_game", "returns": {"type": "(address,address,uint64,uint64,uint64,address)", "struct": "Game"}, "desc": "Get game details by ID", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "game_id"}], "name": "get_game_status", "returns": {"type": "string"}, "desc": "Get human-readable game status", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "game_id"}], "name": "_determine_winner", "returns": {"type": "string"}, "desc": "Internal method to determine the winner", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "name": "game_id"}], "name": "get_winner", "returns": {"type": "address"}, "desc": "Get the winner of a finished game", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "address", "name": "new_owner"}], "name": "transfer_ownership", "returns": {"type": "string"}, "desc": "Transfer contract ownership", "events": [], "readonly": false, "recommendations": {}}], "name": "Tango", "state": {"keys": {"box": {}, "global": {"owner": {"key": "b3duZXI=", "keyType": "AVMString", "valueType": "address"}, "game_counter": {"key": "Z2FtZV9jb3VudGVy", "keyType": "AVMString", "valueType": "AVMUint64"}}, "local": {}}, "maps": {"box": {"games": {"keyType": "uint64", "valueType": "Game", "prefix": "Z2FtZXM="}}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 1, "ints": 1}, "local": {"bytes": 0, "ints": 0}}}, "structs": {"Game": [{"name": "player1", "type": "address"}, {"name": "player2", "type": "address"}, {"name": "move1", "type": "uint64"}, {"name": "move2", "type": "uint64"}, {"name": "status", "type": "uint64"}, {"name": "winner", "type": "address"}]}, "byteCode": {"approval": "CyAEAQAIAiYEDGdhbWVfY291bnRlcgVnYW1lcwQVH3x1BW93bmVyMRhAAAcrMQBnKCNnMRtBAEcxGRREMRhEgggEPfPGiATgFz5bBJsdLsgExbAbsgRLmARjBCqkkEQEPi7I6QQlWobfNhoAjggACwA4AJMBYgF/AiYCQAJnADEZFDEYFBBEIkMjKGVEIggoSwFnMgMxADIDUCMWTEsBUEsBUExQTFBMFilLAVBPAr8qTFCwIkM2GgFJFSQSRBcjKGVESwEPRBYpTFBJvkRJVwAgMgMTRElXICAyAxJESYFQWxREMQBcICIWXFC/gB8VH3x1ABlTdWNjZXNzZnVsbHkgam9pbmVkIGdhbWUhsCJDI0k2GgFJFSQSRBc2GgJHAhUkEkQXSUEAskmBAw5BAKsiRCMoZURLA0lPAg5EFilMUElFBr5MSU4CRQZESYFQWyISRDEATFcAIBJBAGNLA0mBQFsUREsCXEBFBEsESwRJTgK/gUBbQQAbSwOBSFtBABNLAogBpUkVFlcGAkxQKkxQsCJDgCdNb3ZlIHN1Ym1pdHRlZCEgV2FpdGluZyBmb3Igb3Bwb25lbnQuLi5C/8YxAEsESU4CVyAgEkRJgUhbFERLAlxIRQRC/5AjQv9SNhoBSRUkEkQXIyhlREsBD0QWKUxQvkQqTFCwIkM2GgFJFSQSRBcjKGVESwEPRBYpTFC+TElPAkSBUFtJQAAkgBRXYWl0aW5nIGZvciBwbGF5ZXIgMkkVFlcGAkxQKkxQsCJDSSISQQARgAxHYW1lIG9uZ29pbmdC/9tLAVdYIDIDEkEAGoAVR2FtZSBmaW5pc2hlZCAtIERyYXchQv+2gCBHYW1lIGZpbmlzaGVkIC0gV2lubmVyIGRlY2xhcmVkIUL/kTYaAUkVJBJEF4gAfEkVFlcGAkxQKkxQsCJDNhoBSRUkEkQXIyhlREsBD0QWKUxQvkRJgVBbJRJEV1ggKkxQsCJDNhoBSRWBIBJEMQAjK2VEEkRJMgMTRCtMZ4ApFR98dQAjT3duZXJzaGlwIHRyYW5zZmVycmVkIHN1Y2Nlc3NmdWxseSGwIkOKAQGL/xYpTFBJvkxJTwJESYFAW0lPAoFIW0lOAhJBAC+LATIDXFglFlxQiwBMv4AcR2FtZSBmaW5pc2hlZCAtIEl0J3MgYSBkcmF3IYwAiYsCIhJBAAiLA4EDEkAAHYsCJRJBAAeLAyISQAAPiwKBAxJBAHCLAyUSQQBpIkEAOIsBSVcAIFxYjAGAHkdhbWUgZmluaXNoZWQgLSBQbGF5ZXIgMSB3aW5zISUWiwFMXFCLAEy/jACJiwFJVyAgXFiMAYAeR2FtZSBmaW5pc2hlZCAtIFBsYXllciAyIHdpbnMhQv/FI0L/lA==", "clear": "C4EBQw=="}, "desc": "\n    Tango - Rock Paper Scissors PvP Game\n    A decentralized Rock Paper Scissors game on Algorand\n    \n    Move values: 0=None, 1=Rock, 2=Paper, 3=Scissors\n    Status values: 0=Waiting, 1=Ongoing, 2=Finished\n    ", "events": [], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAxIDAgOCAyCiAgICBieXRlY2Jsb2NrICJnYW1lX2NvdW50ZXIiICJnYW1lcyIgMHgxNTFmN2M3NSAib3duZXIiCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYm56IG1haW5fYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MjQKICAgIC8vIHNlbGYub3duZXIgPSBUeG4uc2VuZGVyCiAgICBieXRlY18zIC8vICJvd25lciIKICAgIHR4biBTZW5kZXIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MjUKICAgIC8vIHNlbGYuZ2FtZV9jb3VudGVyID0gVUludDY0KDApCiAgICBieXRlY18wIC8vICJnYW1lX2NvdW50ZXIiCiAgICBpbnRjXzEgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKCm1haW5fYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjE0CiAgICAvLyBjbGFzcyBUYW5nbyhBUkM0Q29udHJhY3QpOgogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IG1haW5fX19hbGdvcHlfZGVmYXVsdF9jcmVhdGVAMTcKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gbXVzdCBiZSBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0CiAgICBwdXNoYnl0ZXNzIDB4M2RmM2M2ODggMHhlMDE3M2U1YiAweDliMWQyZWM4IDB4YzViMDFiYjIgMHg0Yjk4MDQ2MyAweDJhYTQ5MDQ0IDB4M2UyZWM4ZTkgMHgyNTVhODZkZiAvLyBtZXRob2QgImNyZWF0ZV9nYW1lKCl1aW50NjQiLCBtZXRob2QgImpvaW5fZ2FtZSh1aW50NjQpc3RyaW5nIiwgbWV0aG9kICJzdWJtaXRfbW92ZSh1aW50NjQsdWludDY0KXN0cmluZyIsIG1ldGhvZCAiZ2V0X2dhbWUodWludDY0KShhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcykiLCBtZXRob2QgImdldF9nYW1lX3N0YXR1cyh1aW50NjQpc3RyaW5nIiwgbWV0aG9kICJfZGV0ZXJtaW5lX3dpbm5lcih1aW50NjQpc3RyaW5nIiwgbWV0aG9kICJnZXRfd2lubmVyKHVpbnQ2NClhZGRyZXNzIiwgbWV0aG9kICJ0cmFuc2Zlcl9vd25lcnNoaXAoYWRkcmVzcylzdHJpbmciCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBjcmVhdGVfZ2FtZSBqb2luX2dhbWUgc3VibWl0X21vdmUgZ2V0X2dhbWUgZ2V0X2dhbWVfc3RhdHVzIF9kZXRlcm1pbmVfd2lubmVyIGdldF93aW5uZXIgdHJhbnNmZXJfb3duZXJzaGlwCiAgICBlcnIKCm1haW5fX19hbGdvcHlfZGVmYXVsdF9jcmVhdGVAMTc6CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgIQogICAgJiYKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gbXVzdCBiZSBOb09wICYmIGNhbiBvbmx5IGNhbGwgd2hlbiBjcmVhdGluZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy50YW5nby5jb250cmFjdC5UYW5nby5jcmVhdGVfZ2FtZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmNyZWF0ZV9nYW1lOgogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjMxCiAgICAvLyBzZWxmLmdhbWVfY291bnRlciArPSAxCiAgICBpbnRjXzEgLy8gMAogICAgYnl0ZWNfMCAvLyAiZ2FtZV9jb3VudGVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmdhbWVfY291bnRlciBleGlzdHMKICAgIGludGNfMCAvLyAxCiAgICArCiAgICBieXRlY18wIC8vICJnYW1lX2NvdW50ZXIiCiAgICBkaWcgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTo0MQogICAgLy8gd2lubmVyPUFjY291bnQoKQogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MzYKICAgIC8vIHBsYXllcjE9VHhuLnNlbmRlciwKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTozNwogICAgLy8gcGxheWVyMj1BY2NvdW50KCksCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTozNC00MgogICAgLy8gIyBJbml0aWFsaXplIG5ldyBnYW1lCiAgICAvLyBuZXdfZ2FtZSA9IEdhbWUoCiAgICAvLyAgICAgcGxheWVyMT1UeG4uc2VuZGVyLAogICAgLy8gICAgIHBsYXllcjI9QWNjb3VudCgpLAogICAgLy8gICAgIG1vdmUxPVVJbnQ2NCgwKSwgICMgTm9uZQogICAgLy8gICAgIG1vdmUyPVVJbnQ2NCgwKSwgICMgTm9uZQogICAgLy8gICAgIHN0YXR1cz1VSW50NjQoMCksICAjIFdhaXRpbmcKICAgIC8vICAgICB3aW5uZXI9QWNjb3VudCgpCiAgICAvLyApCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTozOAogICAgLy8gbW92ZTE9VUludDY0KDApLCAgIyBOb25lCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjM0LTQyCiAgICAvLyAjIEluaXRpYWxpemUgbmV3IGdhbWUKICAgIC8vIG5ld19nYW1lID0gR2FtZSgKICAgIC8vICAgICBwbGF5ZXIxPVR4bi5zZW5kZXIsCiAgICAvLyAgICAgcGxheWVyMj1BY2NvdW50KCksCiAgICAvLyAgICAgbW92ZTE9VUludDY0KDApLCAgIyBOb25lCiAgICAvLyAgICAgbW92ZTI9VUludDY0KDApLCAgIyBOb25lCiAgICAvLyAgICAgc3RhdHVzPVVJbnQ2NCgwKSwgICMgV2FpdGluZwogICAgLy8gICAgIHdpbm5lcj1BY2NvdW50KCkKICAgIC8vICkKICAgIGl0b2IKICAgIHN3YXAKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6NDQtNDUKICAgIC8vICMgU3RvcmUgZ2FtZSBpbiBib3ggc3RvcmFnZQogICAgLy8gc2VsZi5nYW1lc1tnYW1lX2lkXSA9IG5ld19nYW1lLmNvcHkoKQogICAgc3dhcAogICAgaXRvYgogICAgYnl0ZWNfMSAvLyAiZ2FtZXMiCiAgICBkaWcgMQogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToyOAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBieXRlY18yIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLnRhbmdvLmNvbnRyYWN0LlRhbmdvLmpvaW5fZ2FtZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmpvaW5fZ2FtZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTo0OQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6NTIKICAgIC8vIGFzc2VydCBnYW1lX2lkIDw9IHNlbGYuZ2FtZV9jb3VudGVyLCAiSW52YWxpZCBnYW1lIElEIgogICAgaW50Y18xIC8vIDAKICAgIGJ5dGVjXzAgLy8gImdhbWVfY291bnRlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5nYW1lX2NvdW50ZXIgZXhpc3RzCiAgICBkaWcgMQogICAgPj0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGdhbWUgSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTo1NAogICAgLy8gZ2FtZSA9IHNlbGYuZ2FtZXNbZ2FtZV9pZF0uY29weSgpCiAgICBpdG9iCiAgICBieXRlY18xIC8vICJnYW1lcyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5nYW1lcyBlbnRyeSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTo1Ni01NwogICAgLy8gIyBWYWxpZGF0ZSBnYW1lIGNhbiBiZSBqb2luZWQKICAgIC8vIGFzc2VydCBnYW1lLnBsYXllcjEgIT0gQWNjb3VudCgpLCAiR2FtZSBkb2VzIG5vdCBleGlzdCIKICAgIGR1cAogICAgZXh0cmFjdCAwIDMyCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgICE9CiAgICBhc3NlcnQgLy8gR2FtZSBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjU4CiAgICAvLyBhc3NlcnQgZ2FtZS5wbGF5ZXIyID09IEFjY291bnQoKSwgIkdhbWUgaXMgZnVsbCIKICAgIGR1cAogICAgZXh0cmFjdCAzMiAzMgogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIEdhbWUgaXMgZnVsbAogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjU5CiAgICAvLyBhc3NlcnQgZ2FtZS5zdGF0dXMgPT0gVUludDY0KDApLCAiR2FtZSBhbHJlYWR5IHN0YXJ0ZWQiCiAgICBkdXAKICAgIHB1c2hpbnQgODAgLy8gODAKICAgIGV4dHJhY3RfdWludDY0CiAgICAhCiAgICBhc3NlcnQgLy8gR2FtZSBhbHJlYWR5IHN0YXJ0ZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTo2MS02MgogICAgLy8gIyBBZGQgcGxheWVyIDIgYW5kIHVwZGF0ZSBzdGF0dXMKICAgIC8vIGdhbWUucGxheWVyMiA9IFR4bi5zZW5kZXIKICAgIHR4biBTZW5kZXIKICAgIHJlcGxhY2UyIDMyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6NjMKICAgIC8vIGdhbWUuc3RhdHVzID0gVUludDY0KDEpICAjIE9uZ29pbmcKICAgIGludGNfMCAvLyAxCiAgICBpdG9iCiAgICByZXBsYWNlMiA4MAogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjY1LTY2CiAgICAvLyAjIFVwZGF0ZSBnYW1lIGluIHN0b3JhZ2UKICAgIC8vIHNlbGYuZ2FtZXNbZ2FtZV9pZF0gPSBnYW1lLmNvcHkoKQogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjQ5CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHB1c2hieXRlcyAweDE1MWY3Yzc1MDAxOTUzNzU2MzYzNjU3MzczNjY3NTZjNmM3OTIwNmE2ZjY5NmU2NTY0MjA2NzYxNmQ2NTIxCiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMudGFuZ28uY29udHJhY3QuVGFuZ28uc3VibWl0X21vdmVbcm91dGluZ10oKSAtPiB2b2lkOgpzdWJtaXRfbW92ZToKICAgIGludGNfMSAvLyAwCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTo3MAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXBuIDIKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTo3MwogICAgLy8gYXNzZXJ0IG1vdmUgPj0gMSBhbmQgbW92ZSA8PSAzLCAiSW52YWxpZCBtb3ZlICh1c2UgMT1Sb2NrLCAyPVBhcGVyLCAzPVNjaXNzb3JzKSIKICAgIGJ6IHN1Ym1pdF9tb3ZlX2Jvb2xfZmFsc2VANAogICAgZHVwCiAgICBwdXNoaW50IDMgLy8gMwogICAgPD0KICAgIGJ6IHN1Ym1pdF9tb3ZlX2Jvb2xfZmFsc2VANAogICAgaW50Y18wIC8vIDEKCnN1Ym1pdF9tb3ZlX2Jvb2xfbWVyZ2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTo3MwogICAgLy8gYXNzZXJ0IG1vdmUgPj0gMSBhbmQgbW92ZSA8PSAzLCAiSW52YWxpZCBtb3ZlICh1c2UgMT1Sb2NrLCAyPVBhcGVyLCAzPVNjaXNzb3JzKSIKICAgIGFzc2VydCAvLyBJbnZhbGlkIG1vdmUgKHVzZSAxPVJvY2ssIDI9UGFwZXIsIDM9U2Npc3NvcnMpCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6NzQKICAgIC8vIGFzc2VydCBnYW1lX2lkIDw9IHNlbGYuZ2FtZV9jb3VudGVyLCAiSW52YWxpZCBnYW1lIElEIgogICAgaW50Y18xIC8vIDAKICAgIGJ5dGVjXzAgLy8gImdhbWVfY291bnRlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5nYW1lX2NvdW50ZXIgZXhpc3RzCiAgICBkaWcgMwogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIDw9CiAgICBhc3NlcnQgLy8gSW52YWxpZCBnYW1lIElECiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6NzYKICAgIC8vIGdhbWUgPSBzZWxmLmdhbWVzW2dhbWVfaWRdLmNvcHkoKQogICAgaXRvYgogICAgYnl0ZWNfMSAvLyAiZ2FtZXMiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgYnVyeSA2CiAgICBib3hfZ2V0CiAgICBzd2FwCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJ1cnkgNgogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZ2FtZXMgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6NzgKICAgIC8vIGFzc2VydCBnYW1lLnN0YXR1cyA9PSBVSW50NjQoMSksICJHYW1lIGlzIG5vdCBvbmdvaW5nIgogICAgZHVwCiAgICBwdXNoaW50IDgwIC8vIDgwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgaW50Y18wIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gR2FtZSBpcyBub3Qgb25nb2luZwogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjgwLTgxCiAgICAvLyAjIERldGVybWluZSB3aGljaCBwbGF5ZXIgaXMgc3VibWl0dGluZwogICAgLy8gaWYgVHhuLnNlbmRlciA9PSBnYW1lLnBsYXllcjE6CiAgICB0eG4gU2VuZGVyCiAgICBzd2FwCiAgICBleHRyYWN0IDAgMzIKICAgID09CiAgICBieiBzdWJtaXRfbW92ZV9lbHNlX2JvZHlANwogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjgyCiAgICAvLyBhc3NlcnQgZ2FtZS5tb3ZlMSA9PSBVSW50NjQoMCksICJQbGF5ZXIgMSBhbHJlYWR5IHN1Ym1pdHRlZCBtb3ZlIgogICAgZGlnIDMKICAgIGR1cAogICAgcHVzaGludCA2NCAvLyA2NAogICAgZXh0cmFjdF91aW50NjQKICAgICEKICAgIGFzc2VydCAvLyBQbGF5ZXIgMSBhbHJlYWR5IHN1Ym1pdHRlZCBtb3ZlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6ODMKICAgIC8vIGdhbWUubW92ZTEgPSBtb3ZlCiAgICBkaWcgMgogICAgcmVwbGFjZTIgNjQKICAgIGJ1cnkgNAoKc3VibWl0X21vdmVfYWZ0ZXJfaWZfZWxzZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTo5MC05MQogICAgLy8gIyBVcGRhdGUgZ2FtZQogICAgLy8gc2VsZi5nYW1lc1tnYW1lX2lkXSA9IGdhbWUuY29weSgpCiAgICBkaWcgNAogICAgZGlnIDQKICAgIGR1cAogICAgY292ZXIgMgogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjkzLTk0CiAgICAvLyAjIENoZWNrIGlmIGJvdGggbW92ZXMgYXJlIHN1Ym1pdHRlZAogICAgLy8gaWYgZ2FtZS5tb3ZlMSAhPSBVSW50NjQoMCkgYW5kIGdhbWUubW92ZTIgIT0gVUludDY0KDApOgogICAgcHVzaGludCA2NCAvLyA2NAogICAgZXh0cmFjdF91aW50NjQKICAgIGJ6IHN1Ym1pdF9tb3ZlX2FmdGVyX2lmX2Vsc2VAMTQKICAgIGRpZyAzCiAgICBwdXNoaW50IDcyIC8vIDcyCiAgICBleHRyYWN0X3VpbnQ2NAogICAgYnogc3VibWl0X21vdmVfYWZ0ZXJfaWZfZWxzZUAxNAogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5Ojk1CiAgICAvLyByZXR1cm4gc2VsZi5fZGV0ZXJtaW5lX3dpbm5lcihnYW1lX2lkKQogICAgZGlnIDIKICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzLnRhbmdvLmNvbnRyYWN0LlRhbmdvLl9kZXRlcm1pbmVfd2lubmVyCgpzdWJtaXRfbW92ZV9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy50YW5nby5jb250cmFjdC5UYW5nby5zdWJtaXRfbW92ZUAxNToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTo3MAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWNfMiAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKc3VibWl0X21vdmVfYWZ0ZXJfaWZfZWxzZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTo5NwogICAgLy8gcmV0dXJuIFN0cmluZygiTW92ZSBzdWJtaXR0ZWQhIFdhaXRpbmcgZm9yIG9wcG9uZW50Li4uIikKICAgIHB1c2hieXRlcyAiTW92ZSBzdWJtaXR0ZWQhIFdhaXRpbmcgZm9yIG9wcG9uZW50Li4uIgogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjcwCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGIgc3VibWl0X21vdmVfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMudGFuZ28uY29udHJhY3QuVGFuZ28uc3VibWl0X21vdmVAMTUKCnN1Ym1pdF9tb3ZlX2Vsc2VfYm9keUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5Ojg0CiAgICAvLyBlbGlmIFR4bi5zZW5kZXIgPT0gZ2FtZS5wbGF5ZXIyOgogICAgdHhuIFNlbmRlcgogICAgZGlnIDQKICAgIGR1cAogICAgY292ZXIgMgogICAgZXh0cmFjdCAzMiAzMgogICAgPT0KICAgIGFzc2VydCAvLyBZb3UgYXJlIG5vdCBhIHBsYXllciBpbiB0aGlzIGdhbWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTo4NQogICAgLy8gYXNzZXJ0IGdhbWUubW92ZTIgPT0gVUludDY0KDApLCAiUGxheWVyIDIgYWxyZWFkeSBzdWJtaXR0ZWQgbW92ZSIKICAgIGR1cAogICAgcHVzaGludCA3MiAvLyA3MgogICAgZXh0cmFjdF91aW50NjQKICAgICEKICAgIGFzc2VydCAvLyBQbGF5ZXIgMiBhbHJlYWR5IHN1Ym1pdHRlZCBtb3ZlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6ODYKICAgIC8vIGdhbWUubW92ZTIgPSBtb3ZlCiAgICBkaWcgMgogICAgcmVwbGFjZTIgNzIKICAgIGJ1cnkgNAogICAgYiBzdWJtaXRfbW92ZV9hZnRlcl9pZl9lbHNlQDExCgpzdWJtaXRfbW92ZV9ib29sX2ZhbHNlQDQ6CiAgICBpbnRjXzEgLy8gMAogICAgYiBzdWJtaXRfbW92ZV9ib29sX21lcmdlQDUKCgovLyBzbWFydF9jb250cmFjdHMudGFuZ28uY29udHJhY3QuVGFuZ28uZ2V0X2dhbWVbcm91dGluZ10oKSAtPiB2b2lkOgpnZXRfZ2FtZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weTo5OQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjEwMgogICAgLy8gYXNzZXJ0IGdhbWVfaWQgPD0gc2VsZi5nYW1lX2NvdW50ZXIsICJJbnZhbGlkIGdhbWUgSUQiCiAgICBpbnRjXzEgLy8gMAogICAgYnl0ZWNfMCAvLyAiZ2FtZV9jb3VudGVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmdhbWVfY291bnRlciBleGlzdHMKICAgIGRpZyAxCiAgICA+PQogICAgYXNzZXJ0IC8vIEludmFsaWQgZ2FtZSBJRAogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjEwMwogICAgLy8gcmV0dXJuIHNlbGYuZ2FtZXNbZ2FtZV9pZF0uY29weSgpCiAgICBpdG9iCiAgICBieXRlY18xIC8vICJnYW1lcyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZ2FtZXMgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6OTkKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGJ5dGVjXzIgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMudGFuZ28uY29udHJhY3QuVGFuZ28uZ2V0X2dhbWVfc3RhdHVzW3JvdXRpbmddKCkgLT4gdm9pZDoKZ2V0X2dhbWVfc3RhdHVzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjEwNQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjEwOAogICAgLy8gYXNzZXJ0IGdhbWVfaWQgPD0gc2VsZi5nYW1lX2NvdW50ZXIsICJJbnZhbGlkIGdhbWUgSUQiCiAgICBpbnRjXzEgLy8gMAogICAgYnl0ZWNfMCAvLyAiZ2FtZV9jb3VudGVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmdhbWVfY291bnRlciBleGlzdHMKICAgIGRpZyAxCiAgICA+PQogICAgYXNzZXJ0IC8vIEludmFsaWQgZ2FtZSBJRAogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjEwOQogICAgLy8gZ2FtZSA9IHNlbGYuZ2FtZXNbZ2FtZV9pZF0uY29weSgpCiAgICBpdG9iCiAgICBieXRlY18xIC8vICJnYW1lcyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgc3dhcAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmdhbWVzIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjExMQogICAgLy8gaWYgZ2FtZS5zdGF0dXMgPT0gVUludDY0KDApOgogICAgcHVzaGludCA4MCAvLyA4MAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgYm56IGdldF9nYW1lX3N0YXR1c19lbHNlX2JvZHlAMwogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjExMgogICAgLy8gcmV0dXJuIFN0cmluZygiV2FpdGluZyBmb3IgcGxheWVyIDIiKQogICAgcHVzaGJ5dGVzICJXYWl0aW5nIGZvciBwbGF5ZXIgMiIKCmdldF9nYW1lX3N0YXR1c19hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy50YW5nby5jb250cmFjdC5UYW5nby5nZXRfZ2FtZV9zdGF0dXNAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxMDUKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18yIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgpnZXRfZ2FtZV9zdGF0dXNfZWxzZV9ib2R5QDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTEzCiAgICAvLyBlbGlmIGdhbWUuc3RhdHVzID09IFVJbnQ2NCgxKToKICAgIGR1cAogICAgaW50Y18wIC8vIDEKICAgID09CiAgICBieiBnZXRfZ2FtZV9zdGF0dXNfZWxzZV9ib2R5QDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxMTQKICAgIC8vIHJldHVybiBTdHJpbmcoIkdhbWUgb25nb2luZyIpCiAgICBwdXNoYnl0ZXMgIkdhbWUgb25nb2luZyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxMDUKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGIgZ2V0X2dhbWVfc3RhdHVzX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLnRhbmdvLmNvbnRyYWN0LlRhbmdvLmdldF9nYW1lX3N0YXR1c0A4CgpnZXRfZ2FtZV9zdGF0dXNfZWxzZV9ib2R5QDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTE2CiAgICAvLyBpZiBnYW1lLndpbm5lciA9PSBBY2NvdW50KCk6CiAgICBkaWcgMQogICAgZXh0cmFjdCA4OCAzMgogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgYnogZ2V0X2dhbWVfc3RhdHVzX2Vsc2VfYm9keUA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTE3CiAgICAvLyByZXR1cm4gU3RyaW5nKCJHYW1lIGZpbmlzaGVkIC0gRHJhdyEiKQogICAgcHVzaGJ5dGVzICJHYW1lIGZpbmlzaGVkIC0gRHJhdyEiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTA1CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBiIGdldF9nYW1lX3N0YXR1c19hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy50YW5nby5jb250cmFjdC5UYW5nby5nZXRfZ2FtZV9zdGF0dXNAOAoKZ2V0X2dhbWVfc3RhdHVzX2Vsc2VfYm9keUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjExOQogICAgLy8gcmV0dXJuIFN0cmluZygiR2FtZSBmaW5pc2hlZCAtIFdpbm5lciBkZWNsYXJlZCEiKQogICAgcHVzaGJ5dGVzICJHYW1lIGZpbmlzaGVkIC0gV2lubmVyIGRlY2xhcmVkISIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxMDUKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGIgZ2V0X2dhbWVfc3RhdHVzX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLnRhbmdvLmNvbnRyYWN0LlRhbmdvLmdldF9nYW1lX3N0YXR1c0A4CgoKLy8gc21hcnRfY29udHJhY3RzLnRhbmdvLmNvbnRyYWN0LlRhbmdvLl9kZXRlcm1pbmVfd2lubmVyW3JvdXRpbmddKCkgLT4gdm9pZDoKX2RldGVybWluZV93aW5uZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTIxCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzLnRhbmdvLmNvbnRyYWN0LlRhbmdvLl9kZXRlcm1pbmVfd2lubmVyCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWNfMiAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy50YW5nby5jb250cmFjdC5UYW5nby5nZXRfd2lubmVyW3JvdXRpbmddKCkgLT4gdm9pZDoKZ2V0X3dpbm5lcjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxNTUKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxNTgKICAgIC8vIGFzc2VydCBnYW1lX2lkIDw9IHNlbGYuZ2FtZV9jb3VudGVyLCAiSW52YWxpZCBnYW1lIElEIgogICAgaW50Y18xIC8vIDAKICAgIGJ5dGVjXzAgLy8gImdhbWVfY291bnRlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5nYW1lX2NvdW50ZXIgZXhpc3RzCiAgICBkaWcgMQogICAgPj0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGdhbWUgSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxNTkKICAgIC8vIGdhbWUgPSBzZWxmLmdhbWVzW2dhbWVfaWRdLmNvcHkoKQogICAgaXRvYgogICAgYnl0ZWNfMSAvLyAiZ2FtZXMiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmdhbWVzIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjE2MAogICAgLy8gYXNzZXJ0IGdhbWUuc3RhdHVzID09IFVJbnQ2NCgyKSwgIkdhbWUgbm90IGZpbmlzaGVkIHlldCIKICAgIGR1cAogICAgcHVzaGludCA4MCAvLyA4MAogICAgZXh0cmFjdF91aW50NjQKICAgIGludGNfMyAvLyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIEdhbWUgbm90IGZpbmlzaGVkIHlldAogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjE2MQogICAgLy8gcmV0dXJuIGdhbWUud2lubmVyCiAgICBleHRyYWN0IDg4IDMyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTU1CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18yIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLnRhbmdvLmNvbnRyYWN0LlRhbmdvLnRyYW5zZmVyX293bmVyc2hpcFtyb3V0aW5nXSgpIC0+IHZvaWQ6CnRyYW5zZmVyX293bmVyc2hpcDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxNjMKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDMyPgogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjE2NgogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gc2VsZi5vd25lciwgIk9ubHkgb3duZXIgY2FuIHRyYW5zZmVyIG93bmVyc2hpcCIKICAgIHR4biBTZW5kZXIKICAgIGludGNfMSAvLyAwCiAgICBieXRlY18zIC8vICJvd25lciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5vd25lciBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gT25seSBvd25lciBjYW4gdHJhbnNmZXIgb3duZXJzaGlwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTY3CiAgICAvLyBhc3NlcnQgbmV3X293bmVyICE9IEFjY291bnQoKSwgIkludmFsaWQgbmV3IG93bmVyIGFkZHJlc3MiCiAgICBkdXAKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIG5ldyBvd25lciBhZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTY5CiAgICAvLyBzZWxmLm93bmVyID0gbmV3X293bmVyCiAgICBieXRlY18zIC8vICJvd25lciIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTYzCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHB1c2hieXRlcyAweDE1MWY3Yzc1MDAyMzRmNzc2ZTY1NzI3MzY4Njk3MDIwNzQ3MjYxNmU3MzY2NjU3MjcyNjU2NDIwNzM3NTYzNjM2NTczNzM2Njc1NmM2Yzc5MjEKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy50YW5nby5jb250cmFjdC5UYW5nby5fZGV0ZXJtaW5lX3dpbm5lcihnYW1lX2lkOiB1aW50NjQpIC0+IGJ5dGVzOgpzbWFydF9jb250cmFjdHMudGFuZ28uY29udHJhY3QuVGFuZ28uX2RldGVybWluZV93aW5uZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTIxLTEyMgogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgX2RldGVybWluZV93aW5uZXIoc2VsZiwgZ2FtZV9pZDogVUludDY0KSAtPiBTdHJpbmc6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxMjQKICAgIC8vIGdhbWUgPSBzZWxmLmdhbWVzW2dhbWVfaWRdLmNvcHkoKQogICAgZnJhbWVfZGlnIC0xCiAgICBpdG9iCiAgICBieXRlY18xIC8vICJnYW1lcyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfZ2V0CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZ2FtZXMgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTI2LTEyNwogICAgLy8gIyBDaGVjayBmb3IgZHJhdwogICAgLy8gaWYgZ2FtZS5tb3ZlMSA9PSBnYW1lLm1vdmUyOgogICAgZHVwCiAgICBwdXNoaW50IDY0IC8vIDY0CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgNzIgLy8gNzIKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgID09CiAgICBieiBzbWFydF9jb250cmFjdHMudGFuZ28uY29udHJhY3QuVGFuZ28uX2RldGVybWluZV93aW5uZXJfYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTI4CiAgICAvLyBnYW1lLndpbm5lciA9IEFjY291bnQoKQogICAgZnJhbWVfZGlnIDEKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgcmVwbGFjZTIgODgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxMjkKICAgIC8vIGdhbWUuc3RhdHVzID0gVUludDY0KDIpICAjIEZpbmlzaGVkCiAgICBpbnRjXzMgLy8gMgogICAgaXRvYgogICAgcmVwbGFjZTIgODAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxMzAKICAgIC8vIHNlbGYuZ2FtZXNbZ2FtZV9pZF0gPSBnYW1lLmNvcHkoKQogICAgZnJhbWVfZGlnIDAKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxMzEKICAgIC8vIHJldHVybiBTdHJpbmcoIkdhbWUgZmluaXNoZWQgLSBJdCdzIGEgZHJhdyEiKQogICAgcHVzaGJ5dGVzICJHYW1lIGZpbmlzaGVkIC0gSXQncyBhIGRyYXchIgogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCnNtYXJ0X2NvbnRyYWN0cy50YW5nby5jb250cmFjdC5UYW5nby5fZGV0ZXJtaW5lX3dpbm5lcl9hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTM4CiAgICAvLyAoZ2FtZS5tb3ZlMSA9PSBVSW50NjQoMSkgYW5kIGdhbWUubW92ZTIgPT0gVUludDY0KDMpKSBvcgogICAgZnJhbWVfZGlnIDIKICAgIGludGNfMCAvLyAxCiAgICA9PQogICAgYnogc21hcnRfY29udHJhY3RzLnRhbmdvLmNvbnRyYWN0LlRhbmdvLl9kZXRlcm1pbmVfd2lubmVyX29yX2NvbnRkQDQKICAgIGZyYW1lX2RpZyAzCiAgICBwdXNoaW50IDMgLy8gMwogICAgPT0KICAgIGJueiBzbWFydF9jb250cmFjdHMudGFuZ28uY29udHJhY3QuVGFuZ28uX2RldGVybWluZV93aW5uZXJfYm9vbF90cnVlQDgKCnNtYXJ0X2NvbnRyYWN0cy50YW5nby5jb250cmFjdC5UYW5nby5fZGV0ZXJtaW5lX3dpbm5lcl9vcl9jb250ZEA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjEzOQogICAgLy8gKGdhbWUubW92ZTEgPT0gVUludDY0KDIpIGFuZCBnYW1lLm1vdmUyID09IFVJbnQ2NCgxKSkgb3IKICAgIGZyYW1lX2RpZyAyCiAgICBpbnRjXzMgLy8gMgogICAgPT0KICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy50YW5nby5jb250cmFjdC5UYW5nby5fZGV0ZXJtaW5lX3dpbm5lcl9vcl9jb250ZEA2CiAgICBmcmFtZV9kaWcgMwogICAgaW50Y18wIC8vIDEKICAgID09CiAgICBibnogc21hcnRfY29udHJhY3RzLnRhbmdvLmNvbnRyYWN0LlRhbmdvLl9kZXRlcm1pbmVfd2lubmVyX2Jvb2xfdHJ1ZUA4CgpzbWFydF9jb250cmFjdHMudGFuZ28uY29udHJhY3QuVGFuZ28uX2RldGVybWluZV93aW5uZXJfb3JfY29udGRANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxNDAKICAgIC8vIChnYW1lLm1vdmUxID09IFVJbnQ2NCgzKSBhbmQgZ2FtZS5tb3ZlMiA9PSBVSW50NjQoMikpCiAgICBmcmFtZV9kaWcgMgogICAgcHVzaGludCAzIC8vIDMKICAgID09CiAgICBieiBzbWFydF9jb250cmFjdHMudGFuZ28uY29udHJhY3QuVGFuZ28uX2RldGVybWluZV93aW5uZXJfYm9vbF9mYWxzZUA5CiAgICBmcmFtZV9kaWcgMwogICAgaW50Y18zIC8vIDIKICAgID09CiAgICBieiBzbWFydF9jb250cmFjdHMudGFuZ28uY29udHJhY3QuVGFuZ28uX2RldGVybWluZV93aW5uZXJfYm9vbF9mYWxzZUA5CgpzbWFydF9jb250cmFjdHMudGFuZ28uY29udHJhY3QuVGFuZ28uX2RldGVybWluZV93aW5uZXJfYm9vbF90cnVlQDg6CiAgICBpbnRjXzAgLy8gMQoKc21hcnRfY29udHJhY3RzLnRhbmdvLmNvbnRyYWN0LlRhbmdvLl9kZXRlcm1pbmVfd2lubmVyX2Jvb2xfbWVyZ2VAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTQzCiAgICAvLyBpZiBwbGF5ZXIxX3dpbnM6CiAgICBieiBzbWFydF9jb250cmFjdHMudGFuZ28uY29udHJhY3QuVGFuZ28uX2RldGVybWluZV93aW5uZXJfZWxzZV9ib2R5QDEyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTQ0CiAgICAvLyBnYW1lLndpbm5lciA9IGdhbWUucGxheWVyMQogICAgZnJhbWVfZGlnIDEKICAgIGR1cAogICAgZXh0cmFjdCAwIDMyCiAgICByZXBsYWNlMiA4OAogICAgZnJhbWVfYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGFuZ28vY29udHJhY3QucHk6MTQ1CiAgICAvLyByZXN1bHQgPSBTdHJpbmcoIkdhbWUgZmluaXNoZWQgLSBQbGF5ZXIgMSB3aW5zISIpCiAgICBwdXNoYnl0ZXMgIkdhbWUgZmluaXNoZWQgLSBQbGF5ZXIgMSB3aW5zISIKCnNtYXJ0X2NvbnRyYWN0cy50YW5nby5jb250cmFjdC5UYW5nby5fZGV0ZXJtaW5lX3dpbm5lcl9hZnRlcl9pZl9lbHNlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjE1MAogICAgLy8gZ2FtZS5zdGF0dXMgPSBVSW50NjQoMikgICMgRmluaXNoZWQKICAgIGludGNfMyAvLyAyCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgMQogICAgc3dhcAogICAgcmVwbGFjZTIgODAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxNTEKICAgIC8vIHNlbGYuZ2FtZXNbZ2FtZV9pZF0gPSBnYW1lLmNvcHkoKQogICAgZnJhbWVfZGlnIDAKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxNTMKICAgIC8vIHJldHVybiByZXN1bHQKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpzbWFydF9jb250cmFjdHMudGFuZ28uY29udHJhY3QuVGFuZ28uX2RldGVybWluZV93aW5uZXJfZWxzZV9ib2R5QDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3RhbmdvL2NvbnRyYWN0LnB5OjE0NwogICAgLy8gZ2FtZS53aW5uZXIgPSBnYW1lLnBsYXllcjIKICAgIGZyYW1lX2RpZyAxCiAgICBkdXAKICAgIGV4dHJhY3QgMzIgMzIKICAgIHJlcGxhY2UyIDg4CiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90YW5nby9jb250cmFjdC5weToxNDgKICAgIC8vIHJlc3VsdCA9IFN0cmluZygiR2FtZSBmaW5pc2hlZCAtIFBsYXllciAyIHdpbnMhIikKICAgIHB1c2hieXRlcyAiR2FtZSBmaW5pc2hlZCAtIFBsYXllciAyIHdpbnMhIgogICAgYiBzbWFydF9jb250cmFjdHMudGFuZ28uY29udHJhY3QuVGFuZ28uX2RldGVybWluZV93aW5uZXJfYWZ0ZXJfaWZfZWxzZUAxMwoKc21hcnRfY29udHJhY3RzLnRhbmdvLmNvbnRyYWN0LlRhbmdvLl9kZXRlcm1pbmVfd2lubmVyX2Jvb2xfZmFsc2VAOToKICAgIGludGNfMSAvLyAwCiAgICBiIHNtYXJ0X2NvbnRyYWN0cy50YW5nby5jb250cmFjdC5UYW5nby5fZGV0ZXJtaW5lX3dpbm5lcl9ib29sX21lcmdlQDEwCg==", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"}, "sourceInfo": {"approval": {"pcOffsetMethod": "none", "sourceInfo": [{"pc": [227], "errorMessage": "Game already started"}, {"pc": [213], "errorMessage": "Game does not exist"}, {"pc": [221], "errorMessage": "Game is full"}, {"pc": [339], "errorMessage": "Game is not ongoing"}, {"pc": [731], "errorMessage": "Game not finished yet"}, {"pc": [198, 317, 496, 525, 718], "errorMessage": "Invalid game ID"}, {"pc": [306], "errorMessage": "Invalid move (use 1=Rock, 2=Paper, 3=Scissors)"}, {"pc": [762], "errorMessage": "Invalid new owner address"}, {"pc": [59], "errorMessage": "OnCompletion must be NoOp"}, {"pc": [134], "errorMessage": "OnCompletion must be NoOp && can only call when creating"}, {"pc": [757], "errorMessage": "Only owner can transfer ownership"}, {"pc": [357], "errorMessage": "Player 1 already submitted move"}, {"pc": [466], "errorMessage": "Player 2 already submitted move"}, {"pc": [460], "errorMessage": "You are not a player in this game"}, {"pc": [140, 194, 310, 492, 521, 714], "errorMessage": "check self.game_counter exists"}, {"pc": [205, 332, 502, 535, 724, 827], "errorMessage": "check self.games entry exists"}, {"pc": [755], "errorMessage": "check self.owner exists"}, {"pc": [749], "errorMessage": "invalid number of bytes for arc4.static_array<arc4.uint8, 32>"}, {"pc": [189, 282, 292, 487, 516, 683, 709], "errorMessage": "invalid number of bytes for arc4.uint64"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True)
class Game:
    """Struct for Game"""
    player1: str
    player2: str
    move1: int
    move2: int
    status: int
    winner: str


@dataclasses.dataclass(frozen=True, kw_only=True)
class JoinGameArgs:
    """Dataclass for join_game arguments"""
    game_id: int

    @property
    def abi_method_signature(self) -> str:
        return "join_game(uint64)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class SubmitMoveArgs:
    """Dataclass for submit_move arguments"""
    game_id: int
    move: int

    @property
    def abi_method_signature(self) -> str:
        return "submit_move(uint64,uint64)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetGameArgs:
    """Dataclass for get_game arguments"""
    game_id: int

    @property
    def abi_method_signature(self) -> str:
        return "get_game(uint64)(address,address,uint64,uint64,uint64,address)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetGameStatusArgs:
    """Dataclass for get_game_status arguments"""
    game_id: int

    @property
    def abi_method_signature(self) -> str:
        return "get_game_status(uint64)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class DetermineWinnerArgs:
    """Dataclass for determine_winner arguments"""
    game_id: int

    @property
    def abi_method_signature(self) -> str:
        return "_determine_winner(uint64)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetWinnerArgs:
    """Dataclass for get_winner arguments"""
    game_id: int

    @property
    def abi_method_signature(self) -> str:
        return "get_winner(uint64)address"

@dataclasses.dataclass(frozen=True, kw_only=True)
class TransferOwnershipArgs:
    """Dataclass for transfer_ownership arguments"""
    new_owner: str

    @property
    def abi_method_signature(self) -> str:
        return "transfer_ownership(address)string"


class TangoParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def create_game(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_game()uint64",
        }))

    def join_game(
        self,
        args: tuple[int] | JoinGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "join_game(uint64)string",
            "args": method_args,
        }))

    def submit_move(
        self,
        args: tuple[int, int] | SubmitMoveArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "submit_move(uint64,uint64)string",
            "args": method_args,
        }))

    def get_game(
        self,
        args: tuple[int] | GetGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_game(uint64)(address,address,uint64,uint64,uint64,address)",
            "args": method_args,
        }))

    def get_game_status(
        self,
        args: tuple[int] | GetGameStatusArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_game_status(uint64)string",
            "args": method_args,
        }))

    def determine_winner(
        self,
        args: tuple[int] | DetermineWinnerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "_determine_winner(uint64)string",
            "args": method_args,
        }))

    def get_winner(
        self,
        args: tuple[int] | GetWinnerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_winner(uint64)address",
            "args": method_args,
        }))

    def transfer_ownership(
        self,
        args: tuple[str] | TransferOwnershipArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "transfer_ownership(address)string",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class TangoCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def create_game(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_game()uint64",
        }))

    def join_game(
        self,
        args: tuple[int] | JoinGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "join_game(uint64)string",
            "args": method_args,
        }))

    def submit_move(
        self,
        args: tuple[int, int] | SubmitMoveArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "submit_move(uint64,uint64)string",
            "args": method_args,
        }))

    def get_game(
        self,
        args: tuple[int] | GetGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_game(uint64)(address,address,uint64,uint64,uint64,address)",
            "args": method_args,
        }))

    def get_game_status(
        self,
        args: tuple[int] | GetGameStatusArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_game_status(uint64)string",
            "args": method_args,
        }))

    def determine_winner(
        self,
        args: tuple[int] | DetermineWinnerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "_determine_winner(uint64)string",
            "args": method_args,
        }))

    def get_winner(
        self,
        args: tuple[int] | GetWinnerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_winner(uint64)address",
            "args": method_args,
        }))

    def transfer_ownership(
        self,
        args: tuple[str] | TransferOwnershipArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "transfer_ownership(address)string",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class TangoSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def create_game(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_game()uint64",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def join_game(
        self,
        args: tuple[int] | JoinGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "join_game(uint64)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def submit_move(
        self,
        args: tuple[int, int] | SubmitMoveArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "submit_move(uint64,uint64)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def get_game(
        self,
        args: tuple[int] | GetGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[Game]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_game(uint64)(address,address,uint64,uint64,uint64,address)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(Game, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[Game], parsed_response)

    def get_game_status(
        self,
        args: tuple[int] | GetGameStatusArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_game_status(uint64)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def determine_winner(
        self,
        args: tuple[int] | DetermineWinnerArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "_determine_winner(uint64)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def get_winner(
        self,
        args: tuple[int] | GetWinnerArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_winner(uint64)address",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def transfer_ownership(
        self,
        args: tuple[str] | TransferOwnershipArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "transfer_ownership(address)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class GlobalStateValue(typing.TypedDict):
    """Shape of global_state state key values"""
    owner: str
    game_counter: int

class TangoState:
    """Methods to access state for the current Tango app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def global_state(
        self
    ) -> "_GlobalState":
            """Methods to access global_state for the current app"""
            return _GlobalState(self.app_client)

    @property
    def box(
        self
    ) -> "_BoxState":
            """Methods to access box for the current app"""
            return _BoxState(self.app_client)

class _GlobalState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> GlobalStateValue:
        """Get all current keyed values from global_state state"""
        result = self.app_client.state.global_state.get_all()
        if not result:
            return typing.cast(GlobalStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.global_state.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(GlobalStateValue, converted)

    @property
    def owner(self) -> str:
        """Get the current value of the owner key in global_state state"""
        value = self.app_client.state.global_state.get_value("owner")
        if isinstance(value, dict) and "address" in self._struct_classes:
            return _init_dataclass(self._struct_classes["address"], value)  # type: ignore
        return typing.cast(str, value)

    @property
    def game_counter(self) -> int:
        """Get the current value of the game_counter key in global_state state"""
        value = self.app_client.state.global_state.get_value("game_counter")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

class _BoxState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {
            "Game": Game
        }

    def get_all(self) -> dict[str, typing.Any]:
        """Get all current keyed values from box state"""
        result = self.app_client.state.box.get_all()
        if not result:
            return {}

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.box.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return converted

    @property
    def games(self) -> "_MapState[int, Game]":
        """Get values from the games map in box state"""
        return _MapState(
            self.app_client.state.box,
            "games",
            self._struct_classes.get("Game")
        )

_KeyType = typing.TypeVar("_KeyType")
_ValueType = typing.TypeVar("_ValueType")

class _AppClientStateMethodsProtocol(typing.Protocol):
    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:
        ...
    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:
        ...

class _MapState(typing.Generic[_KeyType, _ValueType]):
    """Generic class for accessing state maps with strongly typed keys and values"""

    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,
                struct_class: typing.Type[_ValueType] | None = None):
        self._state_accessor = state_accessor
        self._map_name = map_name
        self._struct_class = struct_class

    def get_map(self) -> dict[_KeyType, _ValueType]:
        """Get all current values in the map"""
        result = self._state_accessor.get_map(self._map_name)
        if self._struct_class and result:
            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v
                    for k, v in result.items()}  # type: ignore
        return typing.cast(dict[_KeyType, _ValueType], result or {})

    def get_value(self, key: _KeyType) -> _ValueType | None:
        """Get a value from the map by key"""
        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore
        value = self._state_accessor.get_map_value(self._map_name, key_value)
        if value is not None and self._struct_class and isinstance(value, dict):
            return _init_dataclass(self._struct_class, value)  # type: ignore
        return typing.cast(_ValueType | None, value)


class TangoClient:
    """Client for interacting with Tango smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = TangoParams(self.app_client)
        self.create_transaction = TangoCreateTransactionParams(self.app_client)
        self.send = TangoSend(self.app_client)
        self.state = TangoState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "TangoClient":
        return TangoClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "TangoClient":
        return TangoClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "TangoClient":
        return TangoClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "TangoComposer":
        return TangoComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["create_game()uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["join_game(uint64)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["submit_move(uint64,uint64)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_game(uint64)(address,address,uint64,uint64,uint64,address)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> Game | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_game_status(uint64)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["_determine_winner(uint64)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_winner(uint64)address"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["transfer_ownership(address)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | Game | int | str:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class TangoBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):
    """Parameters for creating Tango contract with bare calls"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:
        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)

class TangoFactory(algokit_utils.TypedAppFactoryProtocol[TangoBareCallCreateParams, None, None]):
    """Factory for deploying and managing TangoClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = TangoFactoryParams(self.app_factory)
        self.create_transaction = TangoFactoryCreateTransaction(self.app_factory)
        self.send = TangoFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: TangoBareCallCreateParams | None = None,
        update_params: None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[TangoClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return TangoClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> TangoClient:
        """Get an app client by creator address and name"""
        return TangoClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> TangoClient:
        """Get an app client by app ID"""
        return TangoClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class TangoFactoryParams:
    """Parameters for creating transactions for Tango contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = TangoFactoryCreateParams(app_factory)
        self.update = TangoFactoryUpdateParams(app_factory)
        self.delete = TangoFactoryDeleteParams(app_factory)

class TangoFactoryCreateParams:
    """Parameters for 'create' operations of Tango contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def create_game(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the create_game()uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "create_game()uint64",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def join_game(
        self,
        args: tuple[int] | JoinGameArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the join_game(uint64)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "join_game(uint64)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def submit_move(
        self,
        args: tuple[int, int] | SubmitMoveArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the submit_move(uint64,uint64)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "submit_move(uint64,uint64)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_game(
        self,
        args: tuple[int] | GetGameArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_game(uint64)(address,address,uint64,uint64,uint64,address) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_game(uint64)(address,address,uint64,uint64,uint64,address)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_game_status(
        self,
        args: tuple[int] | GetGameStatusArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_game_status(uint64)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_game_status(uint64)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def determine_winner(
        self,
        args: tuple[int] | DetermineWinnerArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the _determine_winner(uint64)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "_determine_winner(uint64)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_winner(
        self,
        args: tuple[int] | GetWinnerArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_winner(uint64)address ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_winner(uint64)address",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def transfer_ownership(
        self,
        args: tuple[str] | TransferOwnershipArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the transfer_ownership(address)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "transfer_ownership(address)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

class TangoFactoryUpdateParams:
    """Parameters for 'update' operations of Tango contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class TangoFactoryDeleteParams:
    """Parameters for 'delete' operations of Tango contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class TangoFactoryCreateTransaction:
    """Create transactions for Tango contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = TangoFactoryCreateTransactionCreate(app_factory)


class TangoFactoryCreateTransactionCreate:
    """Create new instances of Tango contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class TangoFactorySend:
    """Send calls to Tango contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = TangoFactorySendCreate(app_factory)


class TangoFactorySendCreate:
    """Send create calls to Tango contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[TangoClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return TangoClient(result[0]), result[1]


class TangoComposer:
    """Composer for creating transaction groups for Tango contract calls"""

    def __init__(self, client: "TangoClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    def create_game(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TangoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.create_game(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "create_game()uint64", v
            )
        )
        return self

    def join_game(
        self,
        args: tuple[int] | JoinGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TangoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.join_game(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "join_game(uint64)string", v
            )
        )
        return self

    def submit_move(
        self,
        args: tuple[int, int] | SubmitMoveArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TangoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.submit_move(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "submit_move(uint64,uint64)string", v
            )
        )
        return self

    def get_game(
        self,
        args: tuple[int] | GetGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TangoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_game(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_game(uint64)(address,address,uint64,uint64,uint64,address)", v
            )
        )
        return self

    def get_game_status(
        self,
        args: tuple[int] | GetGameStatusArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TangoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_game_status(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_game_status(uint64)string", v
            )
        )
        return self

    def determine_winner(
        self,
        args: tuple[int] | DetermineWinnerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TangoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.determine_winner(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "_determine_winner(uint64)string", v
            )
        )
        return self

    def get_winner(
        self,
        args: tuple[int] | GetWinnerArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TangoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_winner(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_winner(uint64)address", v
            )
        )
        return self

    def transfer_ownership(
        self,
        args: tuple[str] | TransferOwnershipArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TangoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.transfer_ownership(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "transfer_ownership(address)string", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "TangoComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "TangoComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
